
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CmpNameServiceClientItf &mdash; RuntimeSystemOnlineHelp V3.5.10.0</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.5.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="RuntimeSystemOnlineHelp V3.5.10.0" href="../index.html" />
    <link rel="up" title="Reference" href="index.html" />
    <link rel="next" title="CmpNameServiceServerItf" href="group___cmp_name_service_server_itf.html" />
    <link rel="prev" title="CmpNameServiceClientIecItf" href="group___cmp_name_service_client_iec_itf.html" /> 
  </head>
  <body>
	<div id="header">
		<a href="#" title="CODESYS" target="_top" id="logo"><img src="../_static/logo.png" width="134" height="130" alt=""></a>
		<a href="#" title="CODESYS Documentation" target="_top" id="logo-store"><img src="../_static/logo2.png" width="137" height="130" alt=""></a>
	</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="group___cmp_name_service_server_itf.html" title="CmpNameServiceServerItf"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="group___cmp_name_service_client_iec_itf.html" title="CmpNameServiceClientIecItf"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">RuntimeSystemOnlineHelp V3.5.10.0</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Reference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CmpNameServiceClientItf</a><ul>
<li><a class="reference internal" href="#modules">Modules</a></li>
<li><a class="reference internal" href="#data-structures">Data Structures</a></li>
<li><a class="reference internal" href="#macros">Macros</a></li>
<li><a class="reference internal" href="#typedefs">Typedefs</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
<li><a class="reference internal" href="#macro-definition-documentation">Macro Definition Documentation</a><ul>
<li><a class="reference internal" href="#define-itf-cmpnameserviceclient">#define ITF_CmpNameServiceClient</a></li>
<li><a class="reference internal" href="#define-extitf-cmpnameserviceclient">#define EXTITF_CmpNameServiceClient</a></li>
</ul>
</li>
<li><a class="reference internal" href="#typedef-documentation">Typedef Documentation</a><ul>
<li><a class="reference internal" href="#typedef-void-pfhandlensresponse-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked-pnodeinfo-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete">typedef void( * PFHANDLENSRESPONSE)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED *pNodeInfo, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)</a></li>
<li><a class="reference internal" href="#typedef-void-pfhandlensresponse2-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked2-pnodeinfo2-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete">typedef void( * PFHANDLENSRESPONSE2)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED2 *pNodeInfo2, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)</a></li>
<li><a class="reference internal" href="#typedef-void-pfhandlensresponse3-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked3-pnodeinfo3-unsigned-short-wversion-rts-ui8-byclientblkdrvtype-rts-handle-dwrequestid-int-bcomplete">typedef void( * PFHANDLENSRESPONSE3)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED3 *pNodeInfo3, unsigned short wVersion, RTS_UI8 byClientBlkDrvType, RTS_HANDLE dwRequestId, int bComplete)</a></li>
<li><a class="reference internal" href="#typedef-icmpnameserviceclient-c-icmpnameserviceclient">typedef ICmpNameServiceClient_C ICmpNameServiceClient</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-documentation">Function Documentation</a><ul>
<li><a class="reference internal" href="#rts-result-nsclienthandledata-rts-handle-hrouter-rts-handle-hnetworkinterface-rts-ui8-byserviceid-rts-ui8-bymessageid-peeraddress-addrsender-peeraddress-addrreceiver-protocol-data-unit-pdudata-rts-result-nroutererror">RTS_RESULT NSClientHandleData (RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolvename-const-rts-wchar-pwszname-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">RTS_RESULT NSResolveName (const RTS_WCHAR *pwszName, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolvename3-const-rts-wchar-pwszname-rts-ui32-dwtimeout-rts-bool-bfinishwithfirstnode-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">RTS_RESULT NSResolveName3 (const RTS_WCHAR *pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveaddress-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">RTS_RESULT NSResolveAddress (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveaddress2-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">RTS_RESULT NSResolveAddress2 (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveaddress3-nodeaddress-addrnode-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">RTS_RESULT NSResolveAddress3 (NODEADDRESS addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveblkdrvaddress2-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">RTS_RESULT NSResolveBlkDrvAddress2 (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveblkdrvaddress3-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">RTS_RESULT NSResolveBlkDrvAddress3 (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveall-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">RTS_RESULT NSResolveAll (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveall2-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">RTS_RESULT NSResolveAll2 (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)</a></li>
<li><a class="reference internal" href="#rts-result-nsresolveall3-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">RTS_RESULT NSResolveAll3 (RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)</a></li>
<li><a class="reference internal" href="#rts-result-nsadjustresolvetimeout-rts-ui32-dwremainingtimeout-rts-handle-dwrequestid">RTS_RESULT NSAdjustResolveTimeout (RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="group___cmp_name_service_client_iec_itf.html"
                        title="previous chapter">CmpNameServiceClientIecItf</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="group___cmp_name_service_server_itf.html"
                        title="next chapter">CmpNameServiceServerItf</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/Reference/group___cmp_name_service_client_itf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cmpnameserviceclientitf">
<span id="group-cmp-name-service-client-itf"></span><h1>CmpNameServiceClientItf<a class="headerlink" href="#cmpnameserviceclientitf" title="Permalink to this headline">¶</a></h1>
<p>Interface of CmpNameServiceClient. <a class="reference internal" href="#group-cmp-name-service-client-itf-details"><em>More...</em></a></p>
<div class="section" id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="group___cmp_name_service_client_itf___settings.html#group-cmp-name-service-client-itf-settings"><em>Settings</em></a></li>
</ul>
</div>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>struct <a class="reference internal" href="struct_i_cmp_name_service_client___c.html#struct-i-cmp-name-service-client-c"><em>ICmpNameServiceClient_C</em></a></li>
</ul>
</div>
<div class="section" id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>#define <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga605d5e7cf7212faa9d7a28927d7e00b7"><em>ITF_CmpNameServiceClient</em></a></li>
<li>#define <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga37db05cfd2280fee2157822296e21295"><em>EXTITF_CmpNameServiceClient</em></a></li>
</ul>
</div>
<div class="section" id="typedefs">
<h2>Typedefs<a class="headerlink" href="#typedefs" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>typedef void(* <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga66198a4227da7545b58564a6bd46579e"><em>PFHANDLENSRESPONSE</em></a>)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED <a href="#id1"><span class="problematic" id="id2">*</span></a>pNodeInfo, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)</li>
<li>typedef void(* <a class="reference internal" href="#group-cmp-name-service-client-itf-1gaf6a84eace8e1f663744a437490efaafc"><em>PFHANDLENSRESPONSE2</em></a>)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED2 <a href="#id3"><span class="problematic" id="id4">*</span></a>pNodeInfo2, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)</li>
<li>typedef void(* <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"><em>PFHANDLENSRESPONSE3</em></a>)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED3 <a href="#id5"><span class="problematic" id="id6">*</span></a>pNodeInfo3, unsigned short wVersion, RTS_UI8 byClientBlkDrvType, RTS_HANDLE dwRequestId, int bComplete)</li>
<li>typedef <a class="reference internal" href="struct_i_cmp_name_service_client___c.html#struct-i-cmp-name-service-client-c"><em>ICmpNameServiceClient_C</em></a> <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga21ef1098749be210922fb5ad6ee4a952"><em>ICmpNameServiceClient</em></a></li>
</ul>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga757cf20c2236dcb918eadcc9342f5c32"><em>NSClientHandleData</em></a> (RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, <a class="reference internal" href="struct_p_e_e_r_a_d_d_r_e_s_s.html#struct-p-e-e-r-a-d-d-r-e-s-s"><em>PEERADDRESS</em></a>  addrSender, <a class="reference internal" href="struct_p_e_e_r_a_d_d_r_e_s_s.html#struct-p-e-e-r-a-d-d-r-e-s-s"><em>PEERADDRESS</em></a>  addrReceiver, <a class="reference internal" href="struct_p_r_o_t_o_c_o_l___d_a_t_a___u_n_i_t.html#struct-p-r-o-t-o-c-o-l-d-a-t-a-u-n-i-t"><em>PROTOCOL_DATA_UNIT</em></a>  pduData, RTS_RESULT nRouterError)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga0d1be22d775264af48ab460af623763f"><em>NSResolveName</em></a> (const RTS_WCHAR * pwszName, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga66198a4227da7545b58564a6bd46579e"><em>PFHANDLENSRESPONSE</em></a>  pfCallback)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga047b2f3a83563e5553715d8403ca8ed4"><em>NSResolveName3</em></a> (const RTS_WCHAR * pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"><em>PFHANDLENSRESPONSE3</em></a>  pfCallback3)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga27827a9db89e986d9239c872971553f5"><em>NSResolveAddress</em></a> (<a class="reference internal" href="struct_n_o_d_e_a_d_d_r_e_s_s.html#struct-n-o-d-e-a-d-d-r-e-s-s"><em>NODEADDRESS</em></a>  addrNode, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga66198a4227da7545b58564a6bd46579e"><em>PFHANDLENSRESPONSE</em></a>  pfCallback)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga81e4e93aefd9454aac1406a5c6a3f2be"><em>NSResolveAddress2</em></a> (<a class="reference internal" href="struct_n_o_d_e_a_d_d_r_e_s_s.html#struct-n-o-d-e-a-d-d-r-e-s-s"><em>NODEADDRESS</em></a>  addrNode, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1gaf6a84eace8e1f663744a437490efaafc"><em>PFHANDLENSRESPONSE2</em></a>  pfCallback2)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga814e0166aa6f9bdc9019296bc19c147e"><em>NSResolveAddress3</em></a> (<a class="reference internal" href="struct_n_o_d_e_a_d_d_r_e_s_s.html#struct-n-o-d-e-a-d-d-r-e-s-s"><em>NODEADDRESS</em></a>  addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"><em>PFHANDLENSRESPONSE3</em></a>  pfCallback3)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1gabbbe8cda510898d7479aa053b839249c"><em>NSResolveBlkDrvAddress2</em></a> (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, <a class="reference internal" href="struct_n_e_t_w_o_r_k_a_d_d_r_e_s_s.html#struct-n-e-t-w-o-r-k-a-d-d-r-e-s-s"><em>NETWORKADDRESS</em></a> * pNetworkAddr, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1gaf6a84eace8e1f663744a437490efaafc"><em>PFHANDLENSRESPONSE2</em></a>  pfCallback2)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga0053b9c8d7638fec725e9e0bd634a18d"><em>NSResolveBlkDrvAddress3</em></a> (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, <a class="reference internal" href="struct_n_e_t_w_o_r_k_a_d_d_r_e_s_s.html#struct-n-e-t-w-o-r-k-a-d-d-r-e-s-s"><em>NETWORKADDRESS</em></a> * pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"><em>PFHANDLENSRESPONSE3</em></a>  pfCallback3)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga44c747b6ec51cbe607311aa516d19ad5"><em>NSResolveAll</em></a> (RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga66198a4227da7545b58564a6bd46579e"><em>PFHANDLENSRESPONSE</em></a>  pfCallback)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga1a91919cd550e76a388a9b208c144e8a"><em>NSResolveAll2</em></a> (RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1gaf6a84eace8e1f663744a437490efaafc"><em>PFHANDLENSRESPONSE2</em></a>  pfCallback2)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1gab3e56180d1be42125bf0a6d3c2a2a4f8"><em>NSResolveAll3</em></a> (RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, <a class="reference internal" href="#group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"><em>PFHANDLENSRESPONSE3</em></a>  pfCallback3)</li>
<li>RTS_RESULT <a class="reference internal" href="#group-cmp-name-service-client-itf-1gaabfbca9a8549b262fae760fd5df6202a"><em>NSAdjustResolveTimeout</em></a> (RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId)</li>
</ul>
</div>
<div class="section" id="detailed-description">
<span id="group-cmp-name-service-client-itf-details"></span><h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<p>Interface of CmpNameServiceClient.</p>
<p>External interface for the naming service client</p>
<p><strong>Copyright:</strong></p>
<p>(c) 2003-2016 3S-Smart Software Solutions</p>
</div>
<div class="section" id="macro-definition-documentation">
<h2>Macro Definition Documentation<a class="headerlink" href="#macro-definition-documentation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="define-itf-cmpnameserviceclient">
<span id="group-cmp-name-service-client-itf-1ga605d5e7cf7212faa9d7a28927d7e00b7"></span><h3>#define ITF_CmpNameServiceClient<a class="headerlink" href="#define-itf-cmpnameserviceclient" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="define-extitf-cmpnameserviceclient">
<span id="group-cmp-name-service-client-itf-1ga37db05cfd2280fee2157822296e21295"></span><h3>#define EXTITF_CmpNameServiceClient<a class="headerlink" href="#define-extitf-cmpnameserviceclient" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="typedef-documentation">
<h2>Typedef Documentation<a class="headerlink" href="#typedef-documentation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="typedef-void-pfhandlensresponse-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked-pnodeinfo-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete">
<span id="group-cmp-name-service-client-itf-1ga66198a4227da7545b58564a6bd46579e"></span><h3>typedef void( * PFHANDLENSRESPONSE)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED <a href="#id7"><span class="problematic" id="id8">*</span></a>pNodeInfo, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)<a class="headerlink" href="#typedef-void-pfhandlensresponse-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked-pnodeinfo-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="typedef-void-pfhandlensresponse2-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked2-pnodeinfo2-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete">
<span id="group-cmp-name-service-client-itf-1gaf6a84eace8e1f663744a437490efaafc"></span><h3>typedef void( * PFHANDLENSRESPONSE2)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED2 <a href="#id9"><span class="problematic" id="id10">*</span></a>pNodeInfo2, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete)<a class="headerlink" href="#typedef-void-pfhandlensresponse2-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked2-pnodeinfo2-unsigned-short-wversion-rts-handle-dwrequestid-int-bcomplete" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="typedef-void-pfhandlensresponse3-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked3-pnodeinfo3-unsigned-short-wversion-rts-ui8-byclientblkdrvtype-rts-handle-dwrequestid-int-bcomplete">
<span id="group-cmp-name-service-client-itf-1ga6c948f282a09b39bcd95306cbfcf4cce"></span><h3>typedef void( * PFHANDLENSRESPONSE3)(RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED3 <a href="#id11"><span class="problematic" id="id12">*</span></a>pNodeInfo3, unsigned short wVersion, RTS_UI8 byClientBlkDrvType, RTS_HANDLE dwRequestId, int bComplete)<a class="headerlink" href="#typedef-void-pfhandlensresponse3-rts-result-nresult-nodeaddress-addrnode-nodeinfopacked3-pnodeinfo3-unsigned-short-wversion-rts-ui8-byclientblkdrvtype-rts-handle-dwrequestid-int-bcomplete" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="typedef-icmpnameserviceclient-c-icmpnameserviceclient">
<span id="group-cmp-name-service-client-itf-1ga21ef1098749be210922fb5ad6ee4a952"></span><h3>typedef ICmpNameServiceClient_C ICmpNameServiceClient<a class="headerlink" href="#typedef-icmpnameserviceclient-c-icmpnameserviceclient" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="function-documentation">
<h2>Function Documentation<a class="headerlink" href="#function-documentation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rts-result-nsclienthandledata-rts-handle-hrouter-rts-handle-hnetworkinterface-rts-ui8-byserviceid-rts-ui8-bymessageid-peeraddress-addrsender-peeraddress-addrreceiver-protocol-data-unit-pdudata-rts-result-nroutererror">
<span id="group-cmp-name-service-client-itf-1ga757cf20c2236dcb918eadcc9342f5c32"></span><h3>RTS_RESULT NSClientHandleData (RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError)<a class="headerlink" href="#rts-result-nsclienthandledata-rts-handle-hrouter-rts-handle-hnetworkinterface-rts-ui8-byserviceid-rts-ui8-bymessageid-peeraddress-addrsender-peeraddress-addrreceiver-protocol-data-unit-pdudata-rts-result-nroutererror" title="Permalink to this headline">¶</a></h3>
<p>Protocol handler of CmpNameServiceClient. Attention: Must only be called by CmpRouter to forward an incoming data package.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="6%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>hRouter</td>
<td>Handle of router instance calling this function. For L4 client implementations, by default it is called by the router instance 0. For L4 server implementations, it is called by the router instance which has received the package originally.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>hNetworkInterface</td>
<td>Handle of the network interface receiving originally the package</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>byServiceId</td>
<td>The protocol id of the package</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>byMessageId</td>
<td>The message id of the package</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>addrSender</td>
<td>Sender address. The pointer within will not be valid after this function returns.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>addrReceiver</td>
<td>Receiver address (either the address of this node or a broadcast address). The pointer within will not be valid after this function returns.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pduData</td>
<td>The received data. The data pointer will not be valid after this function returns.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>nRouterError</td>
<td>If this value is not ERR_OK, then this message has been generated by an intermediate node in response to a message previously sent by this node, that could not be delivered. nRouterError identifies the kind of error that happened. pduData then contains a detailed error description depending on the kind of error.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolvename-const-rts-wchar-pwszname-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">
<span id="group-cmp-name-service-client-itf-1ga0d1be22d775264af48ab460af623763f"></span><h3>RTS_RESULT NSResolveName (const RTS_WCHAR <a href="#id13"><span class="problematic" id="id14">*</span></a>pwszName, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)<a class="headerlink" href="#rts-result-nsresolvename-const-rts-wchar-pwszname-rts-handle-dwrequestid-pfhandlensresponse-pfcallback" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with name pwszName. The result is returned asynchronously by calling the pfCallback function, as soon as a node answers. If the node is not unique in the PLC network all nodes with the specified name will answer. The end of the scan is indicated by calling pfCallback with ERR_TIMEOUT. In some cases the pfCallback might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>pwszName</td>
<td>The name of the node to find</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolvename3-const-rts-wchar-pwszname-rts-ui32-dwtimeout-rts-bool-bfinishwithfirstnode-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">
<span id="group-cmp-name-service-client-itf-1ga047b2f3a83563e5553715d8403ca8ed4"></span><h3>RTS_RESULT NSResolveName3 (const RTS_WCHAR <a href="#id15"><span class="problematic" id="id16">*</span></a>pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)<a class="headerlink" href="#rts-result-nsresolvename3-const-rts-wchar-pwszname-rts-ui32-dwtimeout-rts-bool-bfinishwithfirstnode-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with name pwszName. The result is returned asynchronously by calling the pfCallback function, as soon as a node answers. If the node is not unique in the PLC network all nodes with the specified name will answer. Setting the parameter bFinishWithFirstNode to TRUE is useful, if the client want to connect to the first answering node without waiting for the timeout. Typically this is used, if unique node names in the network are assured. The end of the scan is only indicated by calling pfCallback with ERR_TIMEOUT, if bFinishWithFirstNode was set to FALSE or if no node has anwered the request. In some cases the pfCallback might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="15%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>pwszName</td>
<td>The name of the node to find</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwTimeout</td>
<td>Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>bFinishWithFirstNode</td>
<td>If TRUE, pfCallback will be called only once for this request. Further answering nodes are ignored.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback3</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveaddress-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">
<span id="group-cmp-name-service-client-itf-1ga27827a9db89e986d9239c872971553f5"></span><h3>RTS_RESULT NSResolveAddress (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)<a class="headerlink" href="#rts-result-nsresolveaddress-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse-pfcallback" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with the given address. The result is returned asynchronously by calling the pfCallback function, as soon as the node answers. pfCallback will be called only once for this request. In some cases the pfCallback might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>addrNode</td>
<td>Address of the node to find.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveaddress2-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">
<span id="group-cmp-name-service-client-itf-1ga81e4e93aefd9454aac1406a5c6a3f2be"></span><h3>RTS_RESULT NSResolveAddress2 (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)<a class="headerlink" href="#rts-result-nsresolveaddress2-nodeaddress-addrnode-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with the given address. The result is returned asynchronously by calling the pfCallback2 function, as soon as the node answers. pfCallback2 will be called only once for this request. In some cases the pfCallback2 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>addrNode</td>
<td>Address of the node to find.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback2 function.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback2</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveaddress3-nodeaddress-addrnode-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">
<span id="group-cmp-name-service-client-itf-1ga814e0166aa6f9bdc9019296bc19c147e"></span><h3>RTS_RESULT NSResolveAddress3 (NODEADDRESS addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)<a class="headerlink" href="#rts-result-nsresolveaddress3-nodeaddress-addrnode-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with the given address. The result is returned asynchronously by calling the pfCallback3 function, as soon as the node answers. pfCallback3 will be called only once for this request. In some cases the pfCallback3 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>addrNode</td>
<td>Address of the node to find.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwTimeout</td>
<td>Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pfCallback3</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveblkdrvaddress2-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">
<span id="group-cmp-name-service-client-itf-1gabbbe8cda510898d7479aa053b839249c"></span><h3>RTS_RESULT NSResolveBlkDrvAddress2 (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS <a href="#id17"><span class="problematic" id="id18">*</span></a>pNetworkAddr, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)<a class="headerlink" href="#rts-result-nsresolveblkdrvaddress2-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with the given block driver address. This is specified by the block driver type and the address in the local network (e. g. ipaddress and port). If RTS_BLK_DRV_TYPE_NONE is passed, the function returns the address of the own runtime system. In this special use case the node info may not contain a valid node info. The result is returned asynchronously by calling the pfCallback2 function, as soon as the node answers. pfCallback2 will be called only once for this request. In some cases the pfCallback2 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="9%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>byBlkDrvType</td>
<td>The type of the block driver, which should should resolve the address. If set to RTS_BLK_DRV_TYPE_NONE, the address of the own runtime system is returned.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>byFlags</td>
<td>For future use, must be 0.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>byAddrBitLength</td>
<td>Bit length of the network address. Must match with the block driver configuration. Should be 0, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pNetworkAddr</td>
<td>Local network address of the node to find. Should be NULL, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Returned again by the pfCallback2 function. Parallel running requests should have a unique id.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pfCallback2</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveblkdrvaddress3-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">
<span id="group-cmp-name-service-client-itf-1ga0053b9c8d7638fec725e9e0bd634a18d"></span><h3>RTS_RESULT NSResolveBlkDrvAddress3 (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS <a href="#id19"><span class="problematic" id="id20">*</span></a>pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)<a class="headerlink" href="#rts-result-nsresolveblkdrvaddress3-rts-ui8-byblkdrvtype-rts-ui8-byflags-rts-ui8-byaddrbitlength-networkaddress-pnetworkaddr-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3" title="Permalink to this headline">¶</a></h3>
<p>Retrieve the node information for the node with the given block driver address. This is specified by the block driver type and the address in the local network (e. g. ipaddress and port). If RTS_BLK_DRV_TYPE_NONE is passed, the function returns the address of the own runtime system. In this special use case the node info may not contain a valid node info. The result is returned asynchronously by calling the pfCallback3 function, as soon as the node answers. pfCallback3 will be called only once for this request. In some cases the pfCallback3 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="9%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>byBlkDrvType</td>
<td>The type of the block driver, which should should resolve the address. If set to RTS_BLK_DRV_TYPE_NONE, the address of the own runtime system is returned.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>byFlags</td>
<td>For future use, must be 0.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>byAddrBitLength</td>
<td>Bit length of the network address. Must match with the block driver configuration. Should be 0, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pNetworkAddr</td>
<td>Local network address of the node to find. Should be NULL, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>dwTimeout</td>
<td>Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Returned again by the pfCallback3 function. Parallel running requests should have a unique id.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback3</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveall-rts-handle-dwrequestid-pfhandlensresponse-pfcallback">
<span id="group-cmp-name-service-client-itf-1ga44c747b6ec51cbe607311aa516d19ad5"></span><h3>RTS_RESULT NSResolveAll (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback)<a class="headerlink" href="#rts-result-nsresolveall-rts-handle-dwrequestid-pfhandlensresponse-pfcallback" title="Permalink to this headline">¶</a></h3>
<p>Retrieve all nodes in the network. The result is returned asynchronously by calling the pfCallback function once for every answering node. That means pfCallback will be called an unknown number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT. Thus ERR_TIMEOUT is an expected result for this request. In some cases the pfCallback might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pfCallback</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveall2-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2">
<span id="group-cmp-name-service-client-itf-1ga1a91919cd550e76a388a9b208c144e8a"></span><h3>RTS_RESULT NSResolveAll2 (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2)<a class="headerlink" href="#rts-result-nsresolveall2-rts-handle-dwrequestid-pfhandlensresponse2-pfcallback2" title="Permalink to this headline">¶</a></h3>
<p>Retrieve all nodes in the network. The result is returned asynchronously by calling the pfCallback2 function once for every answering node. That means pfCallback2 will be called an unknown number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT. Thus ERR_TIMEOUT is an expected result for this request. In some cases the pfCallback2 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback2 function.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>pfCallback2</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsresolveall3-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3">
<span id="group-cmp-name-service-client-itf-1gab3e56180d1be42125bf0a6d3c2a2a4f8"></span><h3>RTS_RESULT NSResolveAll3 (RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3)<a class="headerlink" href="#rts-result-nsresolveall3-rts-ui32-dwtimeout-rts-handle-dwrequestid-pfhandlensresponse3-pfcallback3" title="Permalink to this headline">¶</a></h3>
<p>Retrieve all nodes in the network. The result is returned asynchronously by calling the pfCallback3 function once for every answering node. That means pfCallback3 will be called an unknown number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT. Thus ERR_TIMEOUT is an expected result for this request. In some cases the pfCallback3 might be called before this function returns. The caller must be prepared to deal with that situation.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>dwTimeout</td>
<td>Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</td>
</tr>
<tr class="row-odd"><td>[in]</td>
<td>pfCallback3</td>
<td>The function to be called when retrieving an answer.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
<div class="section" id="rts-result-nsadjustresolvetimeout-rts-ui32-dwremainingtimeout-rts-handle-dwrequestid">
<span id="group-cmp-name-service-client-itf-1gaabfbca9a8549b262fae760fd5df6202a"></span><h3>RTS_RESULT NSAdjustResolveTimeout (RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId)<a class="headerlink" href="#rts-result-nsadjustresolvetimeout-rts-ui32-dwremainingtimeout-rts-handle-dwrequestid" title="Permalink to this headline">¶</a></h3>
<p>With this function the remaining timeout of all NSResolve... functions can be adjusted. The typical use case is to set the timeout to 0, as soon as the expected node has answered. Beside the new timeout the running NSResolve... function is not affected in its behavior.</p>
<p><strong>Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="22%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[in]</td>
<td>dwRemainingTimeout</td>
<td>Remaining timeout in ms for already running resolve request.</td>
</tr>
<tr class="row-even"><td>[in]</td>
<td>dwRequestId</td>
<td>Id of the request, whose remaining resolve time should be set.</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<p>error code</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="group___cmp_name_service_server_itf.html" title="CmpNameServiceServerItf"
             >next</a> |</li>
        <li class="right" >
          <a href="group___cmp_name_service_client_iec_itf.html" title="CmpNameServiceClientIecItf"
             >previous</a> |</li>
        <li><a href="../index.html">RuntimeSystemOnlineHelp V3.5.10.0</a> &raquo;</li>
          <li><a href="index.html" >Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2016, 3S-Smart Software Solutions GmbH.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>